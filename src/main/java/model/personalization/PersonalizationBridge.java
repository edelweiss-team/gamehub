package model.personalization;

import controller.HomeServlet;
import java.util.ArrayList;
import java.util.List;
import jep.*;
import model.bean.Tag;
import model.bean.User;
import model.dao.TagDAO;
import org.jetbrains.annotations.NotNull;

/**
 * This singleton class represents a bridge between the machine learning model and the java
 * application. Note that this class follows the Singleton design pattern, so just a single instance
 * of it can exist at the same time, and the access to the method is synchronized to deny their
 * access to more than one user at once.
 * Moreover, note that this class's name isn't a reference to the Bridge design pattern in any way.
 */
public class PersonalizationBridge {

    private static final @NotNull JepConfig JEP_CONFIG = new JepConfig();

    //aggiungiamo le include paths per permettere di includere i moduli locali
    static {
        JEP_CONFIG.addIncludePaths(HomeServlet.EXECUTION_PATH + "/WEB-INF/personalization/");
        try {
            SharedInterpreter.setConfig(JEP_CONFIG);
        } catch (JepException e) {
            e.printStackTrace();
        }
    }

    /**
     * Inner class to follow the Bill Pugh singleton implementation approach.
     * This is initialized only when getInstance() is called, granting thread-safety.
     */
    private static class PersonalizationBridgeHelper {
        @NotNull
        private static final PersonalizationBridge INSTANCE = new PersonalizationBridge();
    }

    /**
     * This method gets the instance of {@link PersonalizationBridge} singleton.
     *
     * @return the instance of {@link PersonalizationBridge}
     */
    @NotNull
    public static PersonalizationBridge getInstance() {
        return PersonalizationBridgeHelper.INSTANCE;
    }

    /**
     * Construct a new PersonalizationBridge singleton.
     */
    private PersonalizationBridge() {
        this.dsd = new DatasetSampleDAO();
    }

    /**
     * This method call a python script to register the vote of the user, for the recommended
     * product list generated by the system.
     * Method is synchronized because no more than one user at time may access to the buffer file.
     *
     * @param u the subject user we want to register the vote for the recommended product list
     * @throws VoteRegistrationException if the vote registration fails
     */
    public synchronized void registerVote(@NotNull User u, boolean vote) {
        dsd.doBufferByUsername(u.getUsername()); //scriviamo sul file il campione

        try {
            SharedInterpreter si = new SharedInterpreter();
            //gestione della path
            String path = HomeServlet.EXECUTION_PATH.replace("\\", "/");
            si.exec("import os");
            si.exec("os.chdir('" + path + "')");
            //passiamo il voto da registrare allo script python
            Boolean voteObj = vote;
            si.exec("from samplePrediction import registerVote");
            si.set("vote", voteObj);
            Boolean success = si.getValue("registerVote(vote)", Boolean.class);
            si.close();
            if (!success) {
                throw new VoteRegistrationException();
            }
        } catch (JepException e) {
            throw new VoteRegistrationException(e);
        }
    }

    /**
     * This method queries a python script (and indirectly the machine learning model) to
     * get the tag list for the given user.
     * Method is synchronized because no more than one user at time may access to the buffer file.
     *
     * @param u the subject user we want to get tag list of
     * @return the tag list of the cluster of the user, according to the machine learning model
     * @throws TagPredictionException if the tag prediction fails
     */
    @NotNull
    public synchronized List<Tag> getTagList(@NotNull User u)  {
        List<Tag> tags = new ArrayList<>();
        TagDAO td = new TagDAO();
        dsd.doBufferByUsername(u.getUsername()); //scriviamo sul file il campione
        try {
            //creiamo l'istanza dell'interprete
            SharedInterpreter si = new SharedInterpreter();
            //gestione della path
            String path = HomeServlet.EXECUTION_PATH.replace("\\", "/");
            si.exec("import os");
            si.exec("os.chdir('" + path + "')");

            //prendiamoci i tag dallo script python, che chiamer√† il modello di machine learning
            //tramite il metodo predict()
            si.exec("from samplePrediction import predict");
            ArrayList<String> tagNames = si.getValue("predict()", ArrayList.class);
            si.close();
            tagNames.forEach(t -> tags.add(td.doRetrieveByName(t)));
            return tags;
        } catch (Exception e) {
            throw new TagPredictionException(e);
        }
    }

    /**
     * This method calls a python script to establish whatever the clusterer has to be retraining
     * on new data, based on the votes of the users.
     *
     * @throws CheckRetrainingException if the tag prediction fails
     */
    public synchronized void checkRetraining() {
        //creiamo l'istanza dell'interprete
        try {
            SharedInterpreter si = new SharedInterpreter();
            //gestione della path
            String path = HomeServlet.EXECUTION_PATH.replace("\\", "/");
            si.exec("import os");
            si.exec("os.chdir('" + path + "')");
            //chiamiamo lo script per verificare se il clusterizzatore necessita retraining
            si.exec("from samplePrediction import checkRetraining");
            si.exec("checkRetraining()");
            si.close();
        } catch (JepException e) {
            throw new CheckRetrainingException(e);
        }
    }

    /*public static void main(String[] args) {
        PersonalizationBridge pb = PersonalizationBridge.getInstance();
        pb.checkRetraining();
    }*/

    @NotNull
    private final DatasetSampleDAO dsd;
}
